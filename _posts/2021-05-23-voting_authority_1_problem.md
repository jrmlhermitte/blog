---
keywords: fastai
description: "This blog post attempts to walk through computing the precision of from a range of possibly imprecise scrapers/classifiers."
title: Extracting and Predicting Linked Social Media Accounts
toc: true
branch: master
badges: true
comments: true
categories: [fastpages, jupyter]
hide: false
search_exclude: true
nb_path: _notebooks/2021-05-23-voting_authority_1_problem.ipynb
layout: notebook
---

<!--
#################################################
### THIS FILE WAS AUTOGENERATED! DO NOT EDIT! ###
#################################################
# file to edit: _notebooks/2021-05-23-voting_authority_1_problem.ipynb
-->

<div class="container" id="notebook-container">
        
<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p>With the overwhelming amount of information out there,
it is sometimes hard to find what one is looking for.
For every few true sources, there are often incorrect ones.</p>
<h1 id="Example-Case:-A-Social-Media-Finder">Example Case: A Social Media Finder<a class="anchor-link" href="#Example-Case:-A-Social-Media-Finder"> </a></h1><p>This kind of scenario can often be found in web scraping.
Let's look at a simple example of a "social media finder".
Let's say, we have lists of hundreds of thousands of domains,
and we want to see if we can find linked social media accounts?</p>
<p>It turns out, there is a practical way of determining this which can
often lead to simplifying the understanding of the correctness of
knowledgegraphs that one develops, and I'd like to show you how.</p>

</div>
</div>
</div>
<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<h2 id="Social-Media-Finder-Example">Social Media Finder Example<a class="anchor-link" href="#Social-Media-Finder-Example"> </a></h2><p>Let's say, for example, you have some hypotheses of potential twitter accounts for a certain domain, <code>cnn.com</code>, one <code>@CNN</code> and the other <code>@JohnDoe</code>. How do you know if they are right or wrong?</p>
<p>{% include image.html alt="CNN Example" max-width="400" file="/my_blog/images/copied_from_nb/images/2021_05_24_cnn_example_1.png" %}</p>

</div>
</div>
</div>
<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p>Often in these cases, one will seek for help from multiple sources to get this answer right. And often, these sources will be correct a certain percentage of the time:</p>
<p>{% include image.html alt="CNN Example" max-width="400" file="/my_blog/images/copied_from_nb/images/2021_05_24_cnn_example_2.png" %}</p>
<p>Such a scenario can be common not only in automated scrapers, but even situations such as knowledge graphs, where the "classifier" is actually a human.</p>

</div>
</div>
</div>
<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<h2 id="Social-Media-Finder-Example:-Some-numbers">Social Media Finder Example: Some numbers<a class="anchor-link" href="#Social-Media-Finder-Example:-Some-numbers"> </a></h2><p>In order to better understand how to tackle this problem,
let's look at a specific example.</p>
<p>Let's say you have a bunch of social media finders 
trying to figure out what social media accounts 
are connected to <code>cnn.com</code> and that you have two
that have found <code>@CNN</code> to be 
related {% fn 1 %}:</p>
<ul>
<li>method 1 uses some other independent technique and
is right <strong>65%</strong> of the time for correct values.</li>
<li>method 2 uses a knowledgegraph and is right <strong>80%</strong> of the time</li>
</ul>
<p>And one method that has not found this relation to be true:</p>
<ul>
<li>method 3 uses some scraping technique. Although it has not detected
anything, it has a False negative rate of <strong>60%</strong> (<strong>60%</strong> of the accounts
it fails to link it is wrong about).</li>
</ul>
<p>{% include image.html alt="CNN Example" max-width="400" file="/my_blog/images/copied_from_nb/images/2021_05_24_cnn_example_3.png" %}</p>
<p>What would be this combined precision?</p>

</div>
</div>
</div>
<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p>I'll jump ahead to the answer, it would actually be:
{% raw %}
$$.65 * .8 * .6 / (.65 * .8 * .6 + (1-.65)*(1-.8)*(1-.6) \approx 91.8%$$
{% endraw %}
That's <strong>91.8%</strong>!!!! That's quite jump in confidence.</p>
<p>You could code out the general formula as such:</p>

</div>
</div>
</div>
    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="kn">from</span> <span class="nn">typing</span> <span class="kn">import</span> <span class="n">List</span>
<span class="kn">from</span> <span class="nn">dataclasses</span> <span class="kn">import</span> <span class="n">dataclass</span>


<span class="k">def</span> <span class="nf">combined_p</span><span class="p">(</span><span class="n">precisions_or_fpr</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">float</span><span class="p">]):</span>
    <span class="sd">&quot;&quot;&quot;Compute the combined precision_or_fpr from multiple authorities.&quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">precisions_or_fpr</span><span class="p">:</span>
        <span class="k">return</span> <span class="mi">0</span>
    <span class="n">product</span> <span class="o">=</span> <span class="mi">1</span>
    <span class="n">product_i</span> <span class="o">=</span> <span class="mi">1</span>
    <span class="k">for</span> <span class="n">precision_or_fpr</span> <span class="ow">in</span> <span class="n">precisions_or_fpr</span><span class="p">:</span>
        <span class="n">product</span> <span class="o">*=</span> <span class="n">precision_or_fpr</span>
        <span class="n">product_i</span> <span class="o">*=</span> <span class="p">(</span><span class="mf">1.</span> <span class="o">-</span> <span class="n">precision_or_fpr</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">product</span> <span class="o">/</span> <span class="p">(</span><span class="n">product</span> <span class="o">+</span> <span class="n">product_i</span><span class="p">)</span>
</pre></div>

    </div>
</div>
</div>

</div>
    {% endraw %}

<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p>And run it on our test case above:</p>

</div>
</div>
</div>
    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="n">combined_p</span><span class="p">([</span><span class="mf">0.65</span><span class="p">,</span> <span class="o">.</span><span class="mi">8</span><span class="p">,</span> <span class="o">.</span><span class="mi">6</span><span class="p">])</span>
</pre></div>

    </div>
</div>
</div>

<div class="output_wrapper">
<div class="output">

<div class="output_area">



<div class="output_text output_subarea output_execute_result">
<pre>0.9176470588235295</pre>
</div>

</div>

</div>
</div>

</div>
    {% endraw %}

<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p>How do we get to this?
In order to explain this, I will first go through some definitions
and give the answer. I will then simulate a simple two system
classifier to qualitatively validate the assumption.
The proof will be left for a later post.</p>

</div>
</div>
</div>
<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<h1 id="Definitions">Definitions<a class="anchor-link" href="#Definitions"> </a></h1><p>We will define for any link being determined (ex: <code>@CNN</code> is a twitter user for <code>cnn.com</code>) as it being <code>True</code> if the link exists and <code>False</code> otherwise.</p>
<p>We can define their confidence via their precision $Pr$:
{% raw %}
$$Pr = \frac{TP}{TP + FP}$$
{% endraw %}</p>
<p>Where $TP$ stands for True Positives: the times something actually 
True was also classified True ("Positive") by the classifier. $FP$ stands for 
False positive, and finally $FN$ and $TN$ stand for false negative and 
true negative.</p>
<p>We will also need to know their false negative rate. This is needed
when the authority we are using does not think the link exists:
{% raw %}
$$FNR = \frac{FN}{FN + TP}$$
{% endraw %}</p>
<h2 id="Problem-Statement">Problem Statement<a class="anchor-link" href="#Problem-Statement"> </a></h2><blockquote><p>Given a set of  authorities and measured precision, 
where some classify an item as positive and some negative, 
what is the combined precision that this item is 
likely postive? We also assume here that all 
authorities are <strong>independent</strong>. {% fn 2 %}</p>
</blockquote>
<p>It turns out if you make the independence assumption, 
that there is a very simple answer. Say 
that authorities belonging to $A$ classified an item as 
as positive with each precision $Pr_i$ and that authorities
that belong to $\bar{A}$ did not classify an item as positive
and each have a false negative rate of $FNR_i$. The combined precision
would be:$$Pr_{combined} = \frac{\prod_{i \in A_p} Pr_i \prod_{j \notin A_p} FNR_j}{\prod_{i \in A_p} Pr_i\prod_{j \notin A_p} FNR_j + \prod_{i \in A_p} (1 - Pr_i)\prod_{j \notin A_p} (1 - FNR_j)}
$$</p>

</div>
</div>
</div>
<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<h1 id="Generating-an-Authority-with-a-Model">Generating an Authority with a Model<a class="anchor-link" href="#Generating-an-Authority-with-a-Model"> </a></h1><p>Let's call these extractors authorities.</p>
<p>We want to validate the formula stated above, so let's try
simulating three authorities, compute their precisions and
finally compute their combined precision both from data
and the formula stated above.</p>
<p>We can model an authority by its recall $Re$ and false positive rate $FPR$:</p>
<p>{% raw %}
$$Re = \frac{TP}{T} =  \frac{TP}{TP + FN}$$
{% endraw %}</p>
<p>{% raw %}
$$FPR = \frac{FP}{F} = \frac{FP}{FP + TN}$$
{% endraw %}</p>
<p>We then will simulate the decision of an authority for a set
of possibilities with a known ground truth. When the ground 
truth is True, the probability of the authority reporting 
True will be the recall rate. When the ground truth is 
False, the probability of the authority reporting True 
is $(1- FPR)$ (or the probability of reporting false is 
the false positive rate $FPR$).</p>
<p>Let's now represent this authority with a class.</p>

</div>
</div>
</div>
    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>


<span class="k">class</span> <span class="nc">Authority</span><span class="p">:</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">recall</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span> <span class="n">fpr</span><span class="p">:</span> <span class="nb">float</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">recall</span> <span class="o">=</span> <span class="n">recall</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">fpr</span> <span class="o">=</span> <span class="n">fpr</span>
        
    <span class="k">def</span> <span class="fm">__call__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">actual_value</span><span class="p">:</span> <span class="nb">bool</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Here is our simulated authority.</span>
<span class="sd">        We give it the actual value for simulation purposes.</span>
<span class="sd">        </span>
<span class="sd">        If the value is true, we only predict that it is true</span>
<span class="sd">        in accordance with its recall.</span>
<span class="sd">        If the value is false, we accidentally predict it is </span>
<span class="sd">        true in accordance with its False positive rate.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">actual_value</span> <span class="ow">is</span> <span class="kc">True</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">random</span><span class="p">()</span> <span class="o">&lt;=</span> <span class="bp">self</span><span class="o">.</span><span class="n">recall</span><span class="p">:</span>
                <span class="k">return</span> <span class="kc">True</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">return</span> <span class="kc">False</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">random</span><span class="p">()</span> <span class="o">&lt;=</span> <span class="bp">self</span><span class="o">.</span><span class="n">fpr</span><span class="p">:</span>
                <span class="k">return</span> <span class="kc">True</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">return</span> <span class="kc">False</span>
</pre></div>

    </div>
</div>
</div>

</div>
    {% endraw %}

<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p>And let's create three simple authorities.</p>

</div>
</div>
</div>
<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p>Authority 1 has a low recall but a very low false positive rate:</p>

</div>
</div>
</div>
    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="n">a1</span> <span class="o">=</span> <span class="n">Authority</span><span class="p">(</span><span class="n">recall</span><span class="o">=.</span><span class="mi">3</span><span class="p">,</span> <span class="n">fpr</span><span class="o">=.</span><span class="mi">1</span><span class="p">)</span>
</pre></div>

    </div>
</div>
</div>

</div>
    {% endraw %}

<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p>Authority 2 has a high recall but a worse false positive rate:</p>

</div>
</div>
</div>
    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="n">a2</span> <span class="o">=</span> <span class="n">Authority</span><span class="p">(</span><span class="n">recall</span><span class="o">=.</span><span class="mi">7</span><span class="p">,</span> <span class="n">fpr</span><span class="o">=.</span><span class="mi">4</span><span class="p">)</span>
</pre></div>

    </div>
</div>
</div>

</div>
    {% endraw %}

<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p>Authority 3 has low recall but fairly high false positive rate:</p>

</div>
</div>
</div>
    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="n">a3</span> <span class="o">=</span> <span class="n">Authority</span><span class="p">(</span><span class="n">recall</span><span class="o">=.</span><span class="mi">1</span><span class="p">,</span> <span class="n">fpr</span><span class="o">=.</span><span class="mi">5</span><span class="p">)</span>
</pre></div>

    </div>
</div>
</div>

</div>
    {% endraw %}

<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p>The question here is that, if two independent authorities measure a positive and a third a negative, what is the probability that we have a positive?</p>

</div>
</div>
</div>
<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<h2 id="Simulating-the-data">Simulating the data<a class="anchor-link" href="#Simulating-the-data"> </a></h2>
</div>
</div>
</div>
<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p>Let's create a training set where we will run our comparisons.
Let's run on 1000000 cases, and to make things closer to real world examples, 
let's introduce a bias of 80% toward False as such scenarios are quite
common.</p>

</div>
</div>
</div>
    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="n">N_samples</span> <span class="o">=</span> <span class="mi">1000000</span>
<span class="c1"># bias towards false values</span>
<span class="n">bias</span> <span class="o">=</span> <span class="o">.</span><span class="mi">8</span>
</pre></div>

    </div>
</div>
</div>

</div>
    {% endraw %}

    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">import</span> <span class="nn">pandas</span> <span class="k">as</span> <span class="nn">pd</span>


<span class="n">measurements</span> <span class="o">=</span> <span class="p">[]</span>
<span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">N_samples</span><span class="p">):</span>
    <span class="n">actual_value</span> <span class="o">=</span> <span class="nb">bool</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">random</span><span class="p">()</span> <span class="o">&gt;</span> <span class="n">bias</span><span class="p">)</span>
    
    <span class="n">decision_a1</span> <span class="o">=</span> <span class="n">a1</span><span class="p">(</span><span class="n">actual_value</span><span class="p">)</span>
    <span class="n">decision_a2</span> <span class="o">=</span> <span class="n">a2</span><span class="p">(</span><span class="n">actual_value</span><span class="p">)</span>
    <span class="n">decision_a3</span> <span class="o">=</span> <span class="n">a3</span><span class="p">(</span><span class="n">actual_value</span><span class="p">)</span>
    <span class="n">measurement</span> <span class="o">=</span> <span class="p">{</span>
        <span class="s1">&#39;actual&#39;</span><span class="p">:</span> <span class="n">actual_value</span><span class="p">,</span>
        <span class="s1">&#39;a1&#39;</span><span class="p">:</span> <span class="n">decision_a1</span><span class="p">,</span>
        <span class="s1">&#39;a2&#39;</span><span class="p">:</span> <span class="n">decision_a2</span><span class="p">,</span>
        <span class="s1">&#39;a3&#39;</span><span class="p">:</span> <span class="n">decision_a3</span><span class="p">,</span>
    <span class="p">}</span>
    <span class="n">measurements</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">measurement</span><span class="p">)</span>
    
    
<span class="c1"># Let&#39;s combine our results into a dataframe to make things easier to visualize:</span>
<span class="n">df</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span><span class="n">measurements</span><span class="p">)</span>
</pre></div>

    </div>
</div>
</div>

</div>
    {% endraw %}

    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="n">df</span>
</pre></div>

    </div>
</div>
</div>

<div class="output_wrapper">
<div class="output">

<div class="output_area">


<div class="output_html rendered_html output_subarea output_execute_result">
<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>actual</th>
      <th>a1</th>
      <th>a2</th>
      <th>a3</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>0</th>
      <td>False</td>
      <td>False</td>
      <td>True</td>
      <td>True</td>
    </tr>
    <tr>
      <th>1</th>
      <td>False</td>
      <td>False</td>
      <td>False</td>
      <td>True</td>
    </tr>
    <tr>
      <th>2</th>
      <td>False</td>
      <td>False</td>
      <td>False</td>
      <td>False</td>
    </tr>
    <tr>
      <th>3</th>
      <td>False</td>
      <td>False</td>
      <td>False</td>
      <td>False</td>
    </tr>
    <tr>
      <th>4</th>
      <td>False</td>
      <td>False</td>
      <td>False</td>
      <td>True</td>
    </tr>
    <tr>
      <th>...</th>
      <td>...</td>
      <td>...</td>
      <td>...</td>
      <td>...</td>
    </tr>
    <tr>
      <th>999995</th>
      <td>False</td>
      <td>False</td>
      <td>False</td>
      <td>True</td>
    </tr>
    <tr>
      <th>999996</th>
      <td>False</td>
      <td>False</td>
      <td>True</td>
      <td>True</td>
    </tr>
    <tr>
      <th>999997</th>
      <td>False</td>
      <td>False</td>
      <td>True</td>
      <td>True</td>
    </tr>
    <tr>
      <th>999998</th>
      <td>False</td>
      <td>False</td>
      <td>False</td>
      <td>False</td>
    </tr>
    <tr>
      <th>999999</th>
      <td>False</td>
      <td>False</td>
      <td>False</td>
      <td>False</td>
    </tr>
  </tbody>
</table>
<p>1000000 rows Ã— 4 columns</p>
</div>
</div>

</div>

</div>
</div>

</div>
    {% endraw %}

<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<h2 id="Preparing-the-validation-set">Preparing the validation set<a class="anchor-link" href="#Preparing-the-validation-set"> </a></h2>
</div>
</div>
</div>
<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p>Now, I mentioned we have a bias. If we want to measure the true precision, 
we have to make sure to account for this bias by resampling 
from our training set an equal number of actually true and false
values. It is a bit silly to have introduced a bias in the 
first place from simulated data if we are just going to 
remove it. But this something that can be easily overlooked 
and is always worthwhile considering.</p>

</div>
</div>
</div>
    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="n">df_true</span> <span class="o">=</span> <span class="n">df</span><span class="p">[</span><span class="n">df</span><span class="p">[</span><span class="s1">&#39;actual&#39;</span><span class="p">]]</span>
<span class="n">df_false</span> <span class="o">=</span> <span class="n">df</span><span class="p">[</span><span class="o">~</span><span class="n">df</span><span class="p">[</span><span class="s1">&#39;actual&#39;</span><span class="p">]]</span>
<span class="c1"># count them</span>
<span class="n">number_actually_true</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">df_true</span><span class="p">)</span>
<span class="n">number_actually_false</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">df_false</span><span class="p">)</span>

<span class="c1"># choose smallest number as sampling number</span>
<span class="n">number_to_sample</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">number_actually_true</span><span class="p">,</span> <span class="n">number_actually_false</span><span class="p">)</span>

<span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;Of samples, </span><span class="si">{</span><span class="n">number_actually_true</span><span class="si">}</span><span class="s1"> are true and </span><span class="si">{</span><span class="n">number_actually_false</span><span class="si">}</span><span class="s1"> are false.&#39;</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;We choose to keep </span><span class="si">{</span><span class="n">number_to_sample</span><span class="si">}</span><span class="s1"> of true and false cases.&#39;</span><span class="p">)</span>
</pre></div>

    </div>
</div>
</div>

<div class="output_wrapper">
<div class="output">

<div class="output_area">

<div class="output_subarea output_stream output_stdout output_text">
<pre>Of samples, 200995 are true and 799005 are false.
We choose to keep 200995 of true and false cases.
</pre>
</div>
</div>

</div>
</div>

</div>
    {% endraw %}

    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="n">df_sampled</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">concat</span><span class="p">(</span>
    <span class="p">(</span>
        <span class="n">df_true</span><span class="o">.</span><span class="n">sample</span><span class="p">(</span><span class="n">number_to_sample</span><span class="p">),</span>
        <span class="n">df_false</span><span class="o">.</span><span class="n">sample</span><span class="p">(</span><span class="n">number_to_sample</span><span class="p">),</span>
<span class="p">))</span>
</pre></div>

    </div>
</div>
</div>

</div>
    {% endraw %}

<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<h2 id="Computing-the-Combined-Precision">Computing the Combined Precision<a class="anchor-link" href="#Computing-the-Combined-Precision"> </a></h2>
</div>
</div>
</div>
<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p>Now let's compute the precision of A1 and A2 and verify the false positive rate of A3:</p>

</div>
</div>
</div>
    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="n">prec_a1</span> <span class="o">=</span> <span class="n">df_sampled</span><span class="p">[</span><span class="n">df_sampled</span><span class="p">[</span><span class="s1">&#39;a1&#39;</span><span class="p">]][</span><span class="s1">&#39;actual&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">mean</span><span class="p">()</span>
<span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;The precision of A1 is </span><span class="si">{</span><span class="n">prec_a1</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>
</pre></div>

    </div>
</div>
</div>

<div class="output_wrapper">
<div class="output">

<div class="output_area">

<div class="output_subarea output_stream output_stdout output_text">
<pre>The precision of A1 is 0.7510203575283158
</pre>
</div>
</div>

</div>
</div>

</div>
    {% endraw %}

    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="n">prec_a2</span> <span class="o">=</span> <span class="n">df_sampled</span><span class="p">[</span><span class="n">df_sampled</span><span class="p">[</span><span class="s1">&#39;a2&#39;</span><span class="p">]][</span><span class="s1">&#39;actual&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">mean</span><span class="p">()</span>
<span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;The precision of A2 is </span><span class="si">{</span><span class="n">prec_a2</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>
</pre></div>

    </div>
</div>
</div>

<div class="output_wrapper">
<div class="output">

<div class="output_area">

<div class="output_subarea output_stream output_stdout output_text">
<pre>The precision of A2 is 0.6346139096302646
</pre>
</div>
</div>

</div>
</div>

</div>
    {% endraw %}

    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="n">fnr_a3</span> <span class="o">=</span> <span class="n">df_sampled</span><span class="p">[</span><span class="o">~</span><span class="n">df_sampled</span><span class="p">[</span><span class="s1">&#39;a3&#39;</span><span class="p">]][</span><span class="s1">&#39;actual&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">mean</span><span class="p">()</span>
<span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;The fnr of A3 is </span><span class="si">{</span><span class="n">fnr_a3</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>
</pre></div>

    </div>
</div>
</div>

<div class="output_wrapper">
<div class="output">

<div class="output_area">

<div class="output_subarea output_stream output_stdout output_text">
<pre>The fnr of A3 is 0.6425435872685785
</pre>
</div>
</div>

</div>
</div>

</div>
    {% endraw %}

<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p>Let's now take the samples where A1 and A2 voted for a reference but A3 did not and count the precision of these two:</p>

</div>
</div>
</div>
    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="n">prec_a1a2_not_a3</span> <span class="o">=</span> <span class="n">df_sampled</span><span class="p">[</span><span class="n">df_sampled</span><span class="p">[</span><span class="s1">&#39;a1&#39;</span><span class="p">]</span> <span class="o">&amp;</span> <span class="n">df_sampled</span><span class="p">[</span><span class="s1">&#39;a2&#39;</span><span class="p">]</span> <span class="o">&amp;</span> <span class="o">~</span><span class="n">df_sampled</span><span class="p">[</span><span class="s1">&#39;a3&#39;</span><span class="p">]][</span><span class="s1">&#39;actual&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">mean</span><span class="p">()</span>
<span class="n">matching_rows</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">df_sampled</span><span class="p">[</span><span class="n">df_sampled</span><span class="p">[</span><span class="s1">&#39;a1&#39;</span><span class="p">]</span> <span class="o">&amp;</span> <span class="n">df_sampled</span><span class="p">[</span><span class="s1">&#39;a2&#39;</span><span class="p">]</span> <span class="o">&amp;</span> <span class="o">~</span><span class="n">df_sampled</span><span class="p">[</span><span class="s1">&#39;a3&#39;</span><span class="p">]])</span>
<span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;The precision of A1 and A2 given A3 did not classify is </span><span class="si">{</span><span class="n">prec_a1a2_not_a3</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;This was measured over </span><span class="si">{</span><span class="n">matching_rows</span><span class="si">}</span><span class="s1"> measurements.&#39;</span><span class="p">)</span>
</pre></div>

    </div>
</div>
</div>

<div class="output_wrapper">
<div class="output">

<div class="output_area">

<div class="output_subarea output_stream output_stdout output_text">
<pre>The precision of A1 and A2 given A3 did not classify is 0.9027603364530269
This was measured over 42205 measurements.
</pre>
</div>
</div>

</div>
</div>

</div>
    {% endraw %}

<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<h2 id="Comparing-Against-Our-Formula">Comparing Against Our Formula<a class="anchor-link" href="#Comparing-Against-Our-Formula"> </a></h2>
</div>
</div>
</div>
<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p>Now let's use our formula:</p>

</div>
</div>
</div>
    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="n">prec_a1</span> <span class="o">*</span> <span class="n">prec_a2</span> <span class="o">*</span> <span class="n">fnr_a3</span> <span class="o">/</span> <span class="p">(</span><span class="n">prec_a1</span> <span class="o">*</span> <span class="n">prec_a2</span> <span class="o">*</span> <span class="n">fnr_a3</span>  <span class="o">+</span> <span class="p">(</span><span class="mi">1</span><span class="o">-</span><span class="n">prec_a1</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="n">prec_a2</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="n">fnr_a3</span><span class="p">))</span>
</pre></div>

    </div>
</div>
</div>

<div class="output_wrapper">
<div class="output">

<div class="output_area">



<div class="output_text output_subarea output_execute_result">
<pre>0.9040055451209015</pre>
</div>

</div>

</div>
</div>

</div>
    {% endraw %}

<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p>The results are pretty close! If you are not convinced, I invite you to 
try this out with different authorities with different values of 
recall and false positive rates.</p>
<p>In my next post I will outline a proof.</p>
<p>If you have any questions or comments, or believe something is in 
error, I would love to hear about it in a comment!</p>

</div>
</div>
</div>
<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p>Footnotes:
{{ "These precisions are assumed to be calculated 
on a balanced data set with as many true values as false
values. If you have an imbalanced dataset, it is suggested
to use random downsampling."
| fndetail: 1
}}
{{ "That this last statement is not often
true. A good example is two cat classifiers trained on the same
pretrained network but with different parameters. In this case,
these will not be independent because they will likely start with
the same initial features (i.e. given classifier "A" predicts that
the image is a cat because it has a tail and tall ears, classifier "B"
will probably also likely classify it as a cat). However, the case of web
scraping will often be independent enough. A good example is something
that looks for article titles from different metadata, say the <code>&lt;title&gt;</code>
field and the <code>&lt;meta key='og:title' content='...'&gt;</code> meta field.
In this case, the  presence of the <code>meta</code> field would not directly 
influence the prediction of the title classifier that looks for the 
<code>&lt;title&gt;</code> field."
| fndetail: 2}}</p>

</div>
</div>
</div>
</div>
 

